Date: 2010-02-28 15:36:29
Author: evilsocket
Categories: PHP, Programmazione, Sorgenti
Tags: cache, caching, fast, mysql, performance, PHP, query, serialization, speed, tuning
Title: Usare la serializzazione in PHP per il caching delle query SQL

Da quando ho preso un server dedicato (e ne ho cambiati parecchi XD), ho iniziato a studiare per bene il tuning dei vari demoni che utilizzo per ottenere il massimo delle prestazioni con il minimo consumo di risorse .

Inutile dire che mi si è aperto un mondo, ho decisamente rivalutato il lavoro dei sistemisti (di quelli seri almeno) che spesso può risultare ben più ostico di quello di uno sviluppatore, dovendosi barcamenare tra documentazioni fatte male, file di configurazione gigantenormi, miriadi di parametri per ogni demone ecc ecc ecc.

Una delle funzionalità che non conoscevo e che ho scoperto durante questo periodo di studio, è il caching delle query di MySQL .

In parole povere il server MySQL, dopo aver abilitato tale configurazione, inizierà ad inserire in un suo storage in memoria (almeno credo sia in memoria) i risultati delle query che secondo lui sono cachabili in modo tale da non dover ogni volta rieseguirle, ma dovendo semplicemente prelevare i risultati da quel suo storage aumentando di parecchio le prestazioni generali di una web application che faccia un uso massiccio del database (perchè esistono ora come ora web app degne di chiamarsi così che non usano un db? :P).

E' ovvio che questa funzionalità può essere abilitata se e solo se si ha la possibilità di mettere mano sui file di configurazione del proprio server, cosa che naturalmente è impensabile per coloro che hanno un normale hosting condiviso che a malapena sono liberi di smanettare nella loro directory web.

Per questo motivo ho scritto un piccolo set di funzioni PHP che fanno questa cosa al posto del demone MySQL dando a chiunque la possibilità di aumentare notevolmente le prestazioni del proprio sito PHP/MySQL based ^^

<break>In pratica, chi volesse sviluppare un applicazione web, dovrà utilizzare piùttosto delle funzioni native per mysql, le funzioni che mette a disposizione questa piccola libreria.

A sua volta la libreria si occuperà di eseguire le query, determinare se una determinata query è inseribile in cache o meno, ripulire la cache in caso di aggiornamento dei dati, ecc ecc ecc il tutto sfruttando la <a href="http://php.net/manual/en/function.serialize.php" target="_blank">serializzazione degli oggetti in php</a> .

L'esempio più semplice di utilizzo della libreria potrebbe essere :

[cc lang="php"]<?php
include_once( "dbcache.php" );

dbc_init( // hostname, utente, password e nome del database al quale connettersi
		  "localhost",
		  "utente", 
		  "password", 
		  "nome del db", 
		  // directory in cui salvare i file della cache (deve esistere ed essere scrivibile)
		  "/path/in/cui/salvare/la/cache", 
		  // timeout espresso in secondi di un elemento nella cache, dopo il quale verrà eliminato
		  1800 );
		  
// esegue la query
$obj = dbc_query( "SELECT * FROM notizie" );

// fetcha un array associativo per ogni recordset della query
while( $row = dbc_fetch_assoc($obj) ){
	echo $row['titolo']."<br/>";
}

?>
[/cc]

La prima volta che verrà eseguita, la query sarà inviata al database MySQL vero e proprio ed i risultati messi in cache, dalla seconda in poi invece i risultati verranno prelevati direttamente dallo storage su filesystem aumentando i tempi di risposta ed elaborazione e risparmiando le risorse che avrebbe richiesto il database per eseguire la query.

La cache (che è unica per ogni query, ovvero 10 query in cache equivalgono a 10 file diversi) viene eliminata in due casi :
<ol>
	<li>Se il tempo di creazione di un file nella cache supera il timeout impostato durante l'inizializzazione (quindi se è scaduto.</li>
	<li>Se viene eseguita una query non cachabile, come una INSERT o una UPDATE poichè potenzialmente modificano i dati sul database, rendendo necessario un aggiornamento anche nella cache.</li>
</ol>
Bon, detto questo, spero che la libreria possa essere utile a qualcuno, vi lascio con il codice ^^

[cc lang="php"]<?php
/*
 * This file is part of DBCACHE.
 *
 * Copyleft of Simone Margaritelli aka evilsocket <evilsocket@gmail.com>
 *
 * DBCACHE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * hybris is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with hybris.  If not, see <http://www.gnu.org/licenses/>.
*/

// funzione di inizializzazione
function dbc_init( $dbhost, $dbuser, $dbpass, $dbname, $storage, $lifetime = 1800 ){
	// controllo che la directory di caching esista
	if( !file_exists($storage) ){
		die( "DBCACHE : Path '$storage' does not exist ." );
	}
	// controllo che sia scrivibile
	if( !is_writable($storage) ){
		die( "DBCACHE : Path '$storage' is not writable ." );
	}
	// apro una connessione persistente al db
	mysql_pconnect( $dbhost, $dbuser, $dbpass ) 
		or die( "DBCACHE : ".mysql_error() );
	// seleziono il db
	mysql_select_db( $dbname ) 
		or die( "DBCACHE : ".mysql_error() );
		
	// definisco le variabili che mi servono
	define( "DBCACHE_STORAGE",  $storage );
	define( "DBCACHE_LIFETIME", $lifetime );
}

// serializza i risultati di una query e li salva in cache
function dbc_cache( $hash, $resource ){
	$object = array();
	// indice incrementale per il fetching
	$object['index']      = 0;
	// numero righe
	$object['num_rows']   = mysql_num_rows($resource);
	// numero campi
	$object['num_fields'] = mysql_num_fields($resource);
	// nome dei campi
	$object['fields']     = array();	
	for( $i = 0; $i < $object['num_fields']; $i++ ){              
		$object['fields'][] = mysql_field_name( $resource, $i );
	}
	// recordset
	$object['rows']       = array();
	while( $row = mysql_fetch_array($resource) ){
		$object['rows'][] = $row;	
	}
	// per sicurezza resetto il puntatore alla risorsa
	@mysql_data_seek( $resource, 0 );
	// salvo l'oggetto nella cache
	return dbc_save_cache( $hash, $object );
}
// crea il file di cache per un oggetto
function dbc_save_cache( $hash, &$obj ){
	$file = DBCACHE_STORAGE."/".$hash;
		
	$f = @fopen( $file, 'w' );
	if ( !$f ) {
		return false;
	}
	// imposto un lock esclusivo sul file e ci serializzo i contenuti
	@flock( $f, LOCK_EX );
	@fwrite( $f, serialize( $obj ) );
	@flock( $f, LOCK_UN );
	@fclose( $f );
	@chmod( $file, 0644 );
	
	return $obj;
}
// rimuovo un dato oggetto dalla cache
function dbc_remove( $hash ){
	$file = DBCACHE_STORAGE."/".$hash;
	if( is_file( $file ) ){ 
		@unlink( $file );
	}
}
// cancello la cache, se $old è true elimino solo gli oggetti scaduti,
// altrimenti elminino tutto
function dbc_clean( $old = true ){
	if ( $dir = @opendir( DBCACHE_STORAGE ) ) {
		while ( $hash = readdir( $dir ) ) {
			if ( $hash != '.' && $hash != '..' && $hash != '.htaccess' ) {
				// Clean all
				if (!$old) {
					dbc_remove($hash);
				} elseif ( ( @filemtime( $file ) + DBCACHE_LIFETIME - time() ) < 0) {
					// Clean only old
					dbc_remove($hash);
				}
			}
		}
		closedir( $dir );
	}
}
// funzione per controllare se esiste un oggetto in cache
function dbc_is_cached( $hash ){
	return file_exists( DBCACHE_STORAGE."/".$hash );	
}
// determina se una data query è inseribile in cache .
// solo le query in lettura sono cachabili .
function dbc_is_cachable( $query ){
	return !preg_match( "/\s*(INSERT[\s]+|DELETE[\s]+|UPDATE[\s]+|REPLACE[\s]+|ALTER[\s]+|SET[\s]+|FOUND_ROWS[\s]+|SQL_NO_CACHE[\s]+)/si", $query );	
}
// determina se l'oggetto appartiene alla cache o è una risorsa
function dbc_is_cached_object( &$object ){
	return is_array($object);
}
// esegue una query e ne cacha i risultati, oppure preleva direttamente la cache
// nel caso sia già presente
function dbc_query( $query ) {
	// calcolo l'hash della query
	$hash = md5($query);
	// è già in cache?
	if( dbc_is_cached($hash) ){			
		$file   = DBCACHE_STORAGE."/".$hash;
		$object = null;
		if ( $filemtime = @filemtime( $file ) ) {
			// apro il file nella cache impostando un lock esclusivo
			$f = @fopen( $file, 'r' );
			if ( $f ) {
				@flock( $f, LOCK_SH );
				// deserializzo l'oggetto
				$object = unserialize( stream_get_contents( $f ) );
				@flock( $f, LOCK_UN );
				@fclose( $f );
				// se l'oggetto è scaduto lo rimuovo dalla cache
				if ( ( $filemtime + DBCACHE_LIFETIME - time() ) < 0 ) {
					dbc_remove( $hash );
				}
			}
		}
		return $object;
	}
	// non è nella cache
	else{
		// eseguo la query vera e propria
		$resource = @mysql_query( $query );
		// se la query è cachabile la inserisco nello storage
		if( dbc_is_cachable($query) && ($object = dbc_cache( $hash, $resource )) ){
			return $object;
		}
		// la query non è cachabile, elimino tutta la cache poichè la query appena
		// eseguita ha inserito e/o aggiornato i dati sul db
		else{
			dbc_clean( false );
			return $resource;	
		}
	}
} 
// fetching associativo
function dbc_fetch_assoc( &$obj ){
	if( dbc_is_cached_object($obj) == false ){
		return @mysql_fetch_assoc($obj);
	}
	if( $obj['index'] >= $obj['num_rows'] ){
		$obj['index'] = 0;
		return false;	
	}
	else{
		$row = array();
		for( $i = 0; $i < $obj['num_fields']; $i++ ){
			$row[ $obj['fields'][$i] ] = $obj['rows'][ $obj['index'] ][$i];		
		}
		$obj['index']++;
		return $row;
	}
}
// fetching vettoriale
function dbc_fetch_row( &$obj ){
	if( dbc_is_cached_object($obj) == false ){
		return @mysql_fetch_row($obj);
	}
	
	if( $obj['index'] >= $obj['num_rows'] ){
		$obj['index'] = 0;
		return false;	
	}
	else{
		$row = array();
		for( $i = 0; $i < $obj['num_fields']; $i++ ){
			$row[] = $obj['rows'][ $obj['index'] ][$i];		
		}
		$obj['index']++;
		return $row;
	}	
}
// rimuove l'oggetto dalla memoria
function dbc_free_result( &$obj ){
	if( dbc_is_cached_object($obj) == false ){
		return @mysql_free_result($obj);
	}
	unset($obj);	
}
// restituisce il numero di recordset nell'oggetto
function dbc_num_rows( &$obj ){
	if( dbc_is_cached_object($obj) == false ){
		return @mysql_num_rows($obj);
	}
	return $obj['num_rows'];	
}
// imposta il cursore sull'oggetto
function dbc_data_seek( &$obj, $idx ){
	if( dbc_is_cached_object($obj) == false ){
		return @mysql_data_seek($obj,$idx);
	}
	if( $idx >= $obj['num_rows'] ){
		return false;	
	}
	else{
		$obj['index'] = $idx;
		return true;	
	}
}
// restituisce il numero di campi nell'oggetto
function dbc_num_fields( &$obj ){
	if( dbc_is_cached_object($obj) == false ){
		return @mysql_num_fields($obj,$idx);
	}
	return $obj['num_fields'];	
}
	
?>
[/cc] 